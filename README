GTA SCM
=======

Unused/debug code:
 55976 -  60030 :  4054       - unused after game boot, useful for temp variables? (within range, won't be saved into save)
 56124 -  56153 :    29       - jumped-over code
 56728 -  57945 :  1217       - jumped-over code during init
 59712 -  59754 :    42       - these launch_missions just hit terminate_this_script commands
 59818 -  59818 : first branch
 60030 -  61763 : main loop
 85611 -  86605 -   994       - collectables rewards, hook or term
 92228 -  94428 :  2194       - help thread, begin with terminate_this_script or hook it
127703 - 129492 :  1898 bytes - impound/export debug (impossible branch begins 127588) (patch 127573 to jump to 129471)
141175 - 141401 :   226       - impossible branch in gf init
154564 - 154860 :   296
152364 - 154839 :  2475       - unused gf debug

                :  7,217

intro mission launch site: 59976


NEXT:

* debugger: control debugger features from console (add gvars, read/write memory, etc.)
  - launch/kill game
  - inject any script
  - set script
  - use hex for input/output where appropriate
  - read/write local vars
  - read/write global vars
  - read/write scm memory
  - read/write game memory
  - disassemble instruction at offset
  - patch instruction at offset
  - insert breakpoint at offset
  - handle breakpoint in repl
* debugger: scrollable lists/tables everywhere
* debugger: regions list - maybe replaces code injector
  - detect MAIN + external script's memspaces + block allocator spaces
* debugger: disassemble bytecode in background thread

* compiler: dump all instruction offsets to symbols
* debugger repl: easy-to-use (don't require injection/attachment)
* debugger repl: use local vars instead of global?
* debugger: enable auto-reload, toggle settings, choose files

* debugger: flag on whether to alias script local vars to ruby local vars
* debugger: flag on whether to alias global local vars to ruby global vars
* debugger/compiler: generate symbols that can be used for injected code/strange base offsets
* debugger: DONE: hotkeys, convert all to ctrl+key, ensure no weird focus stuff
* debugger: allow copying text properly
* compiler: handle more errors
* debugger: run without bootstrap script (inject rpc/repl code, find+patch main loop to run them)


* RESOLVED: debugger+code: make breakpoint handler larger, dynamic? (need multiple code sites for multiple dynamic executions)
* RESOLVED: debugger: bulk instruction calls + return values
* RESOLVED: debugger: try to speed up (2nd-level proxy for executing in multiple repl scripts?)
* DONE: debugger: ensure breakpoints work with new repl
* DONE: debugger: cache process.threads calls on each update call

* DONE: generate call graph
  detect all opcodes that use labels (start_mission/switch/headers/etc.)

* stack for function call args?
  is it safe to use if each script leaves the stack empty before yielding?

* DONE: debugger: more mouse click events
* debugger: finalise script viewer
* debugger: persist panels settings
* DONE: debugger: hook up code reloader
* DONE: debugger: hook up repl


* docs: generate list of used/supported opcodes in SA



* code reloader:
  get malloc space
  insert header+code
  header: magic string, size of code, routine offsets for: init/loop/shutdown, base offsets (mem+scm relative)
  when new code is inserted, either:
    * trigger shutdown of old code, start new code
    * trigger old code to jump to new code, retaining local var state
    debug_string("binary data with header")
    init()
    jump(to_next_instruction)
    loop()
    jump(to_next_instruction)
    shutdown()
    jump(to_next_instruction)
    terminate_this_script()
    routines {
      init{}
      loop{}
      shutdown{}
    }

  to halt current code, look at loop_offset, read wait instruction, write return instruction immediately afterwards
  control whether it reloads or shutsdown/reinits by altering main body jumps
  entry/re-entry points: with init: body+0, without init: body+14

  UI columns:
  filename (16+)+3
  mode (6)+3
  injected at (9)+3
  status (the rest)

* game: garage manager - have drop-off areas for it, charge money?
* game: garage manager - deliver cars in traffic, don't just spawn?
* DONE: game: remake collectables finder in ruby
* game: remake collectables finder manager in ruby
  - need to handle respawn timer (and activity timer)
  - read/write these to global vars
* game: rewrite rpc thread in ruby (?)
* game: chill with homies
* game: get nearby cars, allows you to ride trams?
* game: inventory, bank snacks for health regen in levels (consume 1 snack every 10/8/6/4/2 seconds when below n% health)
* game: organise code into subdirs, update assembler to handle if needed

* DONE: compiler: gosubs as a condition (return_true/false opcodes)
* compiler: handle `return` with and without args (return $var == -1)
* compiler: perhaps make gosubs/jumps shorter by assembling as int16 where possible? (only useful for externals)
* ??? compiler: perhaps make gosubs/jumps shorter by making binary lookup table of offsets, then accessing with gosub(dmavar 50000 label_name) ?
* ??? compiler: perhaps make text lookups shorter by assembling binary table, then using global var array into it? (8 * 211+1 = 1696)
* compiler: better output/logging
* compiler: enumerator routines (all_locations().each do |loc_x,loc_y,loc_z|
* compiler: lvar array = use any local args by reference?
* compiler: lvar array = register remapping?
* compiler: trap/exception routines, goto to them to set global var + hit breakpoint in loop
* DONE: compiler: breakpoints: global var to set wait/no-wait on breakpoint loop
* compiler: tail-call optimisation (convert gosub+return into goto)
* compiler: treat routine names as arguments (emit as (label routine_name)). ie. gosub(routine) / goto(routine)
* compiler: function defs with global vars used for arguments/return values, assigned automatically around gosub to routine ( function(args: [:$bitpacker_value,:$bitpacker_bits], returns: [:$bitpacker_value]))

* disassembler: tag all jumps (start_mission/switch statements)
* disassembler: make list of label names, use in disassembly
* disassembler: make list of variable names, use in disasm
* disassembler: use dmavar, not var in disasm

* debugger: use electron for UI

* more RPCs:
  DONE: teleport player: x/y/z/heading/interior id
* DONE-FIXED: disable EmitNode feature, is dangerous (tries to put touchups into unassembled instructions)

* DONE: gxt compile pipeline (rebuild GXT files, insert new entries)
* DONE: generate HeaderExternal from files automatically
* DONE: build external scripts first, patch into script.img, generate header, compile main script
* DONE: main idle loop at 60030->61763
* DONE: patch idle loop to check if externals are running (/watchdog timer for threads)
* DONE: patch save game code to make save-game safe (kill threads/delete blips?)
* DONE: save thread: gosub to save opcode at 88020
* DONE: disassembly mission bytecode in-memory, patch ps2 keyboard checks (15 bytes total (4+4+7) -> goto (7), 4 no-ops (8))
* DONE: compiler header-less mission_label SCMs (with assembler directive?)
* DONE: insert them back into script.img
* DONE: load from main.scm with bootstrap code

* standard lib
* car-id-2-gxt if space permits? (~3600 bytes)
* DONE: bitpacker accumulator routine
* 2d/3d iterator helper
* in-game year/month/day/hour/minute time value routine (use bitpacking?)
* state machine helper?
* distance sorter helper?
* modulo helper
  a - (a/b)*b
  tmp1 = a
  tmp2 = a
  tmp2 /= b
  tmp2 *= b
  tmp1 -= tmp2
  tmp1
* get nearby cars/actors helper

useful for spawning cars? GET_PARKING_NODE_IN_AREA

* Ruby compiler
* DONE: singleton global variable assigner
* export symbols to subdir, name properly
* symbol export for routines, use routine names in stack view
* compiler-level include
* DONE: raw sexp output by assigning array to constant (ROUTINE_ADDR = [:label,:routine_label]; gosub(ROUTINE_ADDR))
* non-hacky string var support
* DONE: emit smallest size for immediate values possible
* DONE: routines {} block, avoids jumps around routines
* function calls using global vars for arguments/return values
* thread {} block, named + scoped local vars (+export symbols)
* DONE: conditional gosubs (routine call as condition, routine calls return_true/false + return)
* DONE: debugger/breakpoints (reuse rpc code?) (rpc_breakpoints_enabled,rpc_breakpoint_pc) (GXTs: CHEATON, FEM_PWT)
* DONE: fix parser bugs with global vars, multiple conditionals
* MOSTLY DONE: pipeline for code/img/gxt compiles/installs
* DONE: refactor menu input handling into routines for each menu with a variable for which button was pressed
* DONE: standard lib that can be compiled in
* DONE: function for bitpacking with counter + number of bits + packed value + unpacked value
* test mission jumps (probs not) (does base pc change? check mission threads)
* switch support (later)
* DONE: array handling
* DSL for patching original scm?

enable/disable keys (hold down r1, use face buttons to navigate, disabling original functions)
enter/ext vehicle: SET_PLAYER_ENTER_CAR_BUTTON
duck: SET_PLAYER_DUCK_BUTTON
shoot: SET_PLAYER_FIRE_BUTTON
jump: SET_PLAYER_JUMP_BUTTON
r1?: SET_PLAYER_DISPLAY_VITAL_STATS_BUTTON
r2/l2?: SET_PLAYER_CYCLE_WEAPON_BUTTON
get_current_population_zone_type
create_user_3d_marker

Features
--------


In-game VM Documentation
-------------

* Can access memory outside of Variables space
* Can kill all running threads with terminate_this_script
* Some .gxt entries require load_mission_text (OVALRIG/HOTR_05)
* Self-modifying code allowed
  * Limits? presumably only first 64kb due to int16 var size
* Integer overflow
  * Overflows from 2147483647 -> -2147483648
* Local variables
  * Per-thread
  * start_new_script takes (offset,*var_args), each nth arg gets assigned to lvar n-1
    ie. start_new_script(1000,50,333) sets (lvar 0) = 50, (lvar 1) = 333
* Out-of-bounds variables
  * var reads outside of memory appear to return 0
  * but writing anything out-of-bounds makes subsequent reads return -68
  * doesn't appear to be wrap-around or shadowing
  * same for lvars
  * terrifying

* Can crash if threads don't yield with wait (?)
* San Andreas can handle ~24,000 noops without crashing (confirm this - i think i just overwrote my main code)

Check:

* Can you use negative jump offsets in normal scripts? how do they behave?
* Out-of-bounds array access


Next
----

  * NodeSet class
    * Can refer to/return other nodes in the nodeset

  * Cache
    - Scm#nodes to json - what about binary data?

  * Rails frontend, resources for:
    - /scms
    - /scms/1

    - /nodes ? offset  = 1024
    - /nodes ? range[] = 1024 & range[] = 2048
    - /nodes ? offset  = 1024 & range   = 512

    - /opcodes/0002

    - /enums
    - /enums/objects

  * UI
    - Serialise scroll positions from the start
    - Combined code/graph viewer
    - Workspaces (windows/layout/target window for shortcuts)
    - Minimap for code view

  * Tests
    - Headers
    - Arg types


Executables
-----------

  * bin/disassemble


Terminology
-----------

