#!/usr/bin/env ruby

# sudo bundle exec ./bin/debugger
if ENV["PWD"].split(/\//)[-1] == "gta-scm"
  $: << "./lib"
  require 'gta_scm'
end

print "\033]0;GtaScm Debugger\a"
print "\n"

require 'gta_scm/process'
require 'gta_scm/thread'
process = GtaScm::Process.new
process.load_symbols!("symbols.gta-scm-symbols")

process.detect_pid_and_attach!

require 'rutui'
require 'gta_scm/rutui_ext'
Thread.abort_on_exception = true
SIZE = RuTui::Screen.size
# current font size = 102 x 60
# smaller font size = 120 x 76
#   wider thread list - thread ids, favourite threads, group named threads together with count

# puts SIZE
# exit

RuTui::Theme.create :scm, {
  :background => RuTui::Pixel.new(236,234,":"),
  :border     => RuTui::Pixel.new(103,234,"-"),
  :textcolor  => 250,
  :unfocused  => 245,
  # :highlight  => 234,
  # :highlight_fg  => 134,
  :highlight  => 244,
  :highlight_fg  => 234,
  :rainbow    => [1,3,11,2,4,5]
}
RuTui::Theme.use :scm

# NEXT:
# process stats
# rpc/tool list
# breakpoint viewer

$panels = {}

$exit = false

class GtaScm::Panel
  attr_accessor :x
  attr_accessor :y
  attr_accessor :width
  attr_accessor :height
  attr_accessor :elements
  attr_accessor :settings
  attr_accessor :controller

  def initialize(x,y,width,height)
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.elements = Hash.new
    self.settings = Hash.new
  end

  def add_elements_to_screen(screen)
    self.elements.each_pair do |key,element|
      screen.add(element)
    end
  end

  def update(process,is_attached,focused = false)
    
  end

  def input(key,is_attached,process)
    
  end

  def mouse_click(x,y,is_attached,process)
    
  end
  def abs_mouse_click(x,y,is_attached,process)
    
  end

  def mouse_move(x,y,is_attached,process)
    
  end
  def abs_mouse_move(x,y,is_attached,process)
    
  end

  def mouse_scroll(x,y,dir,is_attached,process)
    
  end

  def has_textfield
    false
  end


  def dx(xo)
    self.x + xo
  end
  def dy(yo)
    self.y + yo
  end

  def panel_list(data,rows,empty_row)
    list_height = rows - 2
    data = data[0...list_height]
    while data.size < list_height
      data << empty_row
    end
    data
  end

  def on_focus
    self.elements.each_pair do |name,element|
      if name.to_s.match(/header/)
        # element.fg = RuTui::Theme.get(:textcolor)
      else
        element.fg = RuTui::Theme.get(:textcolor)
      end
    end
  end

  def on_blur
    self.elements.each_pair do |name,element|
      if name.to_s.match(/header/)

      else
        element.fg = RuTui::Theme.get(:unfocused)
      end
    end
  end
end


class GtaScm::ProcessPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:text] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    set_text
    self.settings[:pid] = nil
  end

  def set_text(process = nil)
    if self.settings[:pid]
      str = "Process attached (PID: #{self.settings[:pid]}) - k: kill"
    else
      str = "Process detached - l: launch"
    end
    str = str.center(self.width)
    self.elements[:text].bg = 7
    self.elements[:text].fg = 0
    self.elements[:text].set_text(str)
  end

  def update(process,is_attached,focused = false)
    # return if !is_attached
    if is_attached
      self.settings[:pid] = process.pid
    else
      self.settings[:pid] = nil
    end
    # self.set_text(process)
    # self.elements[:text].set_text("focused_panel: #{$focused_panel}")
  end

  def input(key,is_attached,process)
    # return if !self.settings[:pid]
    case key
    when "l"
      if !process.attached?
        process.launch_and_ready!
      end
    when "k"
      if process.attached?
        process.kill!
      end
    end

    self.elements[:text].set_text("key: #{key.inspect} (#{key.bytes.inspect if key.is_a?(String)})")
  end

  def abs_mouse_click(x,y,is_attached,process)
    self.elements[:text].set_text("mouse: (#{x},#{y})")
  end
end


class GtaScm::ThreadSelectorPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:text] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    set_text
    self.settings[:thread_id] = 95
  end

  def set_text(process = nil)
    if process
      str = "Threads (#{process.threads.select(&:active?).size}) - w/s: prev/next"
    else
      str = "Threads - w/s: prev/next"
    end
    str = str.center(self.width)
    self.elements[:text].bg = 7
    self.elements[:text].fg = 0
    self.elements[:text].set_text(str)
  end

  def update(process,is_attached,focused = false)
    return if !is_attached
    self.set_text(process)
  end

  def input(key,is_attached,process)
    case key
    when "w"
      self.settings[:thread_id] += 1
      self.settings[:key] = "w"
    when "s"
      self.settings[:thread_id] -= 1
      self.settings[:key] = "s"
    end

    self.settings[:thread_id] = 95 if self.settings[:thread_id] >= 96
    self.settings[:thread_id] = 0  if self.settings[:thread_id] <= 0
  end
end

class GtaScm::LvarsPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements = {}
    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    set_text
    self.elements[:table] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(1),
      table: [["",""]],
      cols: [
        { title: "", length: (self.width.to_f * 0.6).to_i - 3 },
        { title: "", length: (self.width.to_f * 0.4).to_i - 3 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    # self.settings[:thread_id] ||= 95
    self.settings[:lvars_count] = 32
    self.settings[:lvar_selected] = 0
    self.settings[:types] = [:int] * self.settings[:lvars_count]
    self.settings[:names] = [nil] * self.settings[:lvars_count]
  end

  def set_text(process = nil)
    str = "Local Variables - e/d: prev/next"
    str = str.center(self.width)
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text(str)
  end


  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    self.settings[:thread_id] = self.controller.settings[:thread_id] if self.controller

    if thread = process.threads[self.settings[:thread_id]]

      if thread_symbols = process.thread_symbols[thread.name]
        thread_symbols.each_pair do |lvar,info|
          if info[1]
            self.settings[:types][ lvar.to_i ] = info[1].to_sym
          end
          if info[0]
            self.settings[:names][ lvar.to_i ] = info[0]
          end
        end
      else
        # self.settings[:types] = [:int] * 32
        self.settings[:names] = [nil] * 32
      end


      lvars_int   = thread.local_variables_ints
      lvars_float = thread.local_variables_floats

      data = self.settings[:lvars_count].times.map do |ii|
        label = self.settings[:names][ii] || "#{self.settings[:types][ii]} lvar #{ii}"
        case self.settings[:types][ii]
        when :int
          # [ii.to_s,"int",lvars_int[ii].to_s,self.settings[:names][ii].to_s]
          [label,lvars_int[ii].to_s]
        when :float
          # [ii.to_s,"flt",lvars_float[ii].round(3).to_s,self.settings[:names][ii].to_s]
          [label,lvars_float[ii].round(3).to_s]
        when :bin
          # [ii.to_s,"bin",lvars_int[ii].to_s(2).rjust(32,"0").chars.in_groups_of(8).map{|g| g.join}.join("-")]
          [label,lvars_int[ii].to_s(2).rjust(32,"0").chars.in_groups_of(8).map{|g| g.join}.join("-")]
        else
          nil
        end
      end.compact

      # data << ["#{self.settings[:thread_id]}","#{$key}","#{self.settings[:key]}",""]
      # self.settings[:thread_id] -= 1

      self.elements[:table].clear_highlight!
      self.elements[:table].highlight(self.settings[:lvar_selected])
      self.elements[:table].set_table(data)
    end
  end

  def input(key,is_attached,process)
    case key
    when "d"
      self.settings[:lvar_selected] += 1
      self.settings[:key] = "d"
    when "e"
      self.settings[:lvar_selected] -= 1
      self.settings[:key] = "e"
    when "c"
      type = self.settings[:types][ self.settings[:lvar_selected] ]
      new_type = case type
      when :int
        :float
      when :float
        :str
      when :str
        :bin
      when :bin
        :int
      end
      self.settings[:types][ self.settings[:lvar_selected] ] = new_type
      self.settings[:key] = "c"
    end

    self.settings[:lvar_selected] = 32 if self.settings[:lvar_selected] >= 32
    self.settings[:lvar_selected] = 0  if self.settings[:lvar_selected] <= 0
  end
end

class GtaScm::GvarsPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    set_text
    self.elements[:table] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(1),
      table: [["","",""]],
      cols: [
        { title: "", length: 5 },
        { title: "", length: (self.width.to_f * 0.6).to_i - 7 },
        { title: "", length: (self.width.to_f * 0.4).to_i - 7 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    self.settings[:gvars] = []
    self.settings[:types] = []
    self.settings[:names] = []

    # [
      # [172  ,:int ,"interior"],
      # [100  ,:int ,"stat"],
      # [160  ,:int ,"day of week"],
      # [616  ,:int ,"language"],
      # [1636,:int ,"mission_flag"],
      # [21136,:int ,"game timer"],

      # [7084,:int ,"watchdog timer"],
      # [7088,:int ,"extscript 78 count"],
      # [4484,:int ,"watchdog check"],
      # [4488,:int ,"watchdog timer"],
      # [4492,:int ,"extscript 78 count"],
      # [4496,:int ,"code state"],
      # [3428,:int ,"code version"],
      # [3432,:int ,"save version"],
      # [7088,:int ,"debug enabled"],
      # [7084,:int ,"debug feedback enabled"],
    #   [7120,:int ,"array item"],
    #   [7124,:int ,"array index"],
    #   [7128,:int ,"array 0"],
    #   [7132,:int ,"array 1"],
    #   [7136,:int ,"array 2"],
    #   [7140,:int ,"array 3"],
    #   [7144,:int ,"array 4"],
    #   [7148,:int ,"array 5"],
    #   [7152,:int ,"array 6"],
    #   [7156,:int ,"array 7"],
    #   [21828,:int ,"unused ?"],
    #   [21832,:int ,"unused ?"],
    #   [21836,:int ,"unused ?"],
    #   [21840,:int ,"unused ?"],
    #   [21844,:int ,"unused ?"],
    #   [40848,:int ,"unused ?"],
    # ]



    # .each do |(gvar,type,name)|
    #   self.settings[:gvars] << gvar
    #   self.settings[:types] << type
    #   self.settings[:names] << name
    # end
    self.settings[:gvars_inited] = false
    self.settings[:selected_gvar] = 0
  end

  def set_text(process = nil)
    str = "Global Variables - r/f: prev/next"
    str = str.center(self.width)
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text(str)
  end

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    if !self.settings[:gvars_inited]
      gvars = process.symbols_var_offsets.each_pair.map do |name,offset|
        type = process.symbols_var_types[offset]
        if name || offset == 21744
          type ||= :int
          type == :int32 if type == :int
          type == :float32 if type == :float
          [offset.to_i,name,type]
        end
      end.compact
      gvars.sort_by!(&:first)
      gvars.each do |(offset,name,type)|
        self.settings[:gvars] << offset
        self.settings[:types] << type.to_sym
        self.settings[:names] << name
      end
      self.settings[:gvars_inited] = true
    end

    data = self.settings[:gvars].map.each_with_index do |gvar,idx|
      label = self.settings[:names][idx] || "gvar #{gvar}"
      value = process.read_scm_var(gvar,self.settings[:types][idx]).to_s
      ["#{gvar}",label,value]
    end.compact
    self.elements[:table].set_table(data)
  end
end

class GtaScm::MissionSkipperPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    self.elements[:header2] = RuTui::Text.new(x: dx(0), y: dy(1), text: "")
    self.settings[:bytecode] = nil
    self.settings[:patchsites] = {}
    set_text
    self.elements[:table] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(2),
      table: [["",""]],
      cols: [
        { title: "", length: 1 },
        { title: "", length: 20 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
  end

  def set_text(process = nil)
    if process && thread = process.threads.detect{|t| t.is_mission == 1}
      str = "Debug Patches - p: patch"
      str2 = "Thread #{thread.thread_id} #{thread.name}"
    else
      str = "Debug Patches"
      str2 = "No mission"
    end
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text(str.center(self.width))
    self.elements[:header2].set_text(str2.center(self.width))
  end

  DEBUG_OPCODE = [
    0xd6, 0x00, 0x04, 0x00, # andor
    0x35, 0x07, 0x04,       # ps2 key pressed int8
  ]

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    if thread = process.threads.detect{|t| t.is_mission == 1}

      if !self.settings[:bytecode]
        self.settings[:thread_base_pc] = thread.base_pc
        self.settings[:bytecode] = process.read(thread.base_pc,69_000).bytes
        self.settings[:bytecode].each_with_index do |_,i|
          if self.settings[:bytecode][i...(i+7)] == DEBUG_OPCODE
            # inst_andor = self.settings[:bytecode][i..(i+3)]
            inst_keypress = self.settings[:bytecode][(i+4)..(i+7)]
            # inst_goto_false = self.settings[:bytecode][(i+8)..(i+14)]
            keypress = inst_keypress.last.chr
            # puts "found debug opcode at #{i}"
            self.settings[:patchsites][keypress] ||= []
            self.settings[:patchsites][keypress] << i
          end
        end
      end

      data = self.settings[:patchsites].each_pair.map do |keypress,offsets|
        [
          "#{keypress}",
          "#{offsets.join(",")}"
        ]
      end
      # data = [["","thread: #{thread.thread_id} #{thread.name}"]] + data
      if data.present?
        self.elements[:table].set_table(data)
      end
      set_text(process)
    else
      self.settings[:bytecode] = nil
      self.settings[:thread_base_pc] = nil
      self.settings[:patchsites] = {}
      self.elements[:table].set_table([["","No mission"]])
      set_text(process)
    end
  end

  def input(key,is_attached,process)
    if key == "p"

      if thread = process.threads.detect{|t| t.is_mission == 1}
        self.settings[:patchsites].each_pair do |keypress,offsets|
          offsets.each do |offset|
            # puts "patching branch at #{offset}"
            wait7 = [0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00]
            wait4 = [0x01, 0x00, 0x04, 0x00]
            noop = (wait7 + wait4 + wait4).map(&:chr).join
            # puts "writing no-op #{noop.inspect} to #{offset} (#{thread.base_pc + offset})"
            process.write( self.settings[:thread_base_pc] + offset , noop )
          end
        end
      end

    end
  end
end



class GtaScm::BreakpointPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    self.elements[:text] = RuTui::Text.new(x: dx(0), y: dy(1), text: "")
    self.settings[:breakpoint_enabled] = false
    set_text
  end

  def set_text(process = nil)
    
  end

  def _set_text(str,str2)
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text(str.center(self.width))
    self.elements[:text].set_text(str2.center(self.width))
  end

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    return

    self.settings[:breakpoint_enabled] = process.read_scm_var( process.scm_var_offset_for("debug_breakpoint_pc") , :int32 )
    self.settings[:breakpoint_waiting] = process.read_scm_var( process.scm_var_offset_for("debug_breakpoint_enabled") , :int32 )
    str_enable = self.settings[:breakpoint_enabled] == 1 ? "o: disable" : "o: enable"

    if self.settings[:breakpoint_waiting] == 1
      breakpoint_handler = process.scm_label_offset_for("debug_breakpoint")

      breakpoint_thread = process.threads.detect{|t|
        (breakpoint_handler..(breakpoint_handler+64)).include?(t.scm_pc)
      }

      if breakpoint_thread
        breakpoint_gosub = breakpoint_thread.scm_return_stack.last
        str = "Breakpoint - i: resume, #{str_enable}"
        str2 = "#{breakpoint_thread.thread_id} #{breakpoint_thread.name} #{breakpoint_gosub}"
        _set_text(str,str2)
      else
        str = "Breakpoint - i: resume, #{str_enable}"
        str2 = "unknown thread"
        _set_text(str,str2)
      end
    else
      str = "Breakpoint - #{str_enable}"
      str2 = ""
      _set_text(str,str2)
    end
  end

  def input(key,is_attached,process)
    if key == "i"
      process.write_scm_var( process.scm_var_offset_for("debug_breakpoint_enabled") , 0 , :int32 )
    end
    if key == "o"
      if self.settings[:breakpoint_enabled] == 1
        self.settings[:breakpoint_enabled] = 0
        process.write_scm_var( process.scm_var_offset_for("debug_breakpoint_pc") , 0 , :int32 )
      else
        self.settings[:breakpoint_enabled] = 1
        process.write_scm_var( process.scm_var_offset_for("debug_breakpoint_pc") , 1 , :int32 )
        end
    end
  end
end


class GtaScm::CodeInjectorPanel < GtaScm::Panel
  TABLE_LINE_COUNT = 1
  STATUS_LINE_COUNT = 4

  def initialize(*)
    super

    tx,ty = 0,0

    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(ty), text: "")
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text("Code Injector - u: inject, j: kill".center(self.width))
    ty += 1

    self.elements[:status_box] = RuTui::Box.new(
      x: dx(0),
      y: dy(ty + TABLE_LINE_COUNT + 3),
      width: self.width,
      height: STATUS_LINE_COUNT + 2,
      corner: RuTui::Pixel.new(RuTui::Theme.get(:border).fg,RuTui::Theme.get(:background).bg,"+")
    )

    self.elements[:table] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(ty),
      table: [["","","",""]],
      cols: [
        { title: "Filename", length: 21 },
        { title: "Mode", length: 6 },
        { title: "LoadTime", length: 8 },
        { title: "Status", length: 14 },
      ],
      header: true,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    ty += TABLE_LINE_COUNT + 4


    self.settings[:injectors] = [
      ["inject",198_000,"injectd",7092]
    ]


    (0...STATUS_LINE_COUNT).each do |line_idx|
      self.elements[:"status_line_#{line_idx}"] = RuTui::Text.new(x: dx(2), y: dy(ty), text: "line #{line_idx}")
      ty += 1
    end

  end

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    data = self.settings[:injectors].map do |injector|
      thread = process.threads.detect{|t| t.name == injector[2] }
      status = thread ? thread.status : "nothread"
      [injector[0],injector[1].to_s,injector[2],injector[3].to_s,"#{status}"]
    end
    data = [["","","",""]]
    self.elements[:table].set_table(data)

  end

  attr_accessor :allocation_count
  VM_ALLOCATE_SIZE = 1024
  def input(key,is_attached,process)
    self.allocation_count ||= 0

    if key == "u"
      print RuTui::Ansi.clear_color + RuTui::Ansi.clear
      dir = "scm-src/sa-experiments"
      filename = self.settings[:injectors][0][0]
      thread_name = self.settings[:injectors][0][2]

      # HORRIBLE HACK:
      # vm_allocate gives us back 64-bit pointers so we can't use it for VM memory allocation...
      # code_offset = Ragweed::Wraposx::vm_allocate(process.process.task,base_offset,VM_ALLOCATE_SIZE,true)
      
      # ...so lets just write into the top 1gb of user-process memory space
      code_offset = (2**30) + (VM_ALLOCATE_SIZE * self.allocation_count += 1)

      code_offset -= process.scm_offset

      scm = GtaScm::Scm.load_string("san-andreas","")
      scm.load_opcode_definitions!
      asm = GtaScm::Assembler::Sexp.new(dir)
      asm.code_offset = code_offset
      def asm.install_features!
        class << self
          include GtaScm::Assembler::Feature::VariableAllocator
          include GtaScm::Assembler::Feature::VariableHeaderAllocator
        end
        self.on_feature_init()
      end
      output = StringIO.new
      asm.assemble(scm,filename,output)
      output.rewind
      code = output.read

      process.write(process.scm_offset + code_offset, code)
      process.rpc(1,code_offset,thread_name || "xinject")
    end

    if key == "j"
      thread_name = self.settings[:injectors][0][2]
      process.rpc(2,"#{thread_name}")
    end
  end
end



class GtaScm::ThreadListPanel < GtaScm::Panel
  def initialize(*)
    super
    self.elements[:table] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(0),
      table: [[""]],
      cols: [
        { title: "", length: 10 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    # self.settings[:thread_id] ||= 95
    self.settings[:selected_row] = 0
  end

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    self.settings[:thread_id] = self.controller.settings[:thread_id] if self.controller

    self.elements[:table].clear_highlight_lines!
    self.elements[:table].set_highlight_line_color(3)

    data = self.panel_list( threads(process).map.each_with_index do |thread,idx|
      if thread.thread_id == self.settings[:thread_id]
        self.settings[:selected_row] = idx
      end
      color = ""
      if thread.name.andand.match(/^x/)
        self.elements[:table].add_highlight_line(idx)
      end
      if thread.active? && !thread.prev_opcode_is_wait?(process)
        self.elements[:table].add_highlight_line(idx,5)
      end
      [
        "#{thread.status_icon} #{(thread.nice_name||"").ljust(8," ")}"
      ]
    end, self.height , [""])

    self.elements[:table].clear_highlight!
    self.elements[:table].highlight( self.settings[:selected_row] )
    self.elements[:table].set_table(data)
  end

  def mouse_click(x,y,is_attached,process)
    self.settings[:selected_row] = 80
    if y >= 1 && y < self.height - 1
      if thread = threads(process)[y - 1]
        self.controller.settings[:thread_id] = thread.thread_id
      end
    end
  end

  def threads(process)
    process.threads.reverse
  end
end


class GtaScm::ThreadInfoPanel < GtaScm::Panel
  def initialize(*)
    super
    # self.elements[:table2] = RuTui::Table.new({
    #   x: self.dx(0),
    #   y: self.dy(9),
    #   table: [[""]*11],
    #   cols: ([{ title: "", length: 1 }] * 9)+[{ title: "", length: 4 }] * 2,
    #   header: false,
    #   hover: RuTui::Theme.get(:highlight),
    #   hover_fg: RuTui::Theme.get(:highlight_fg),
    # })
    self.elements[:table1] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(0),
      table: [["",""]],
      cols: [
        { title: "", length: (self.width.to_f * 0.6).to_i },
        { title: "", length: (self.width.to_f * 0.4).to_i },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    self.elements[:table3] = RuTui::Table.new({
      x: self.dx(20),
      y: self.dy(13),
      table: [[""]],
      cols: [
        { title: "", length: 12 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
    self.elements[:table4] = RuTui::Table.new({
      x: self.dx(0),
      y: self.dy(13),
      table: [[""]],
      cols: [
        { title: "", length: 17 },
      ],
      header: false,
      hover: RuTui::Theme.get(:highlight),
      hover_fg: RuTui::Theme.get(:highlight_fg),
    })
  end

  def update(process,is_attached,focused = false)
    if !is_attached
      return
    end

    self.settings[:thread_id] = self.controller.settings[:thread_id] if self.controller

    if thread = process.threads[self.settings[:thread_id]]
      data1 = [
        ["#{thread.thread_id.to_s.rjust(2,"0")} #{(thread.name || "").ljust(7," ")}","#{thread.status}"],
        ["",""],
        ["PC","#{thread.scm_pc}"],
        ["Base PC","#{thread.base_pc_scm}"],
        ["",""],
        ["Wake Time","#{thread.wake_time}"],
        ["Timer A","#{thread.timer_a}"],
        ["Timer B","#{thread.timer_b}"],
        ["",""],
        ["",""],
        ["",""],
        ["Stack",""],
      ]
      # data2 = [
      #   ["BranchRes","#{thread.branch_result}"],
      #   ["Mission","#{thread.is_mission}"],
      #   ["External","#{thread.is_external}"],
      #   ["BranchRes2","#{thread.branch_result2}"],
      #   ["NotFlag","#{thread.not_flag}"],
      #   ["DaState","#{thread.death_arrest_state}"],
      #   ["DaExecd","#{thread.death_arrest_executed}"],
      #   ["SkipPC","#{thread.scene_skip_pc}"],
      #   ["MissionFlg","#{thread.mission_flag}"],
      #   ["Unknown1","#{thread.unknown1}"],
      #   ["Unknown2","#{thread.unknown2}"],
      # ]
      # data2 = [[
      #   "#{thread.branch_result}",
      #   "#{thread.is_mission}",
      #   "#{thread.is_external}",
      #   "#{thread.branch_result2}",
      #   "#{thread.not_flag}",
      #   "#{thread.death_arrest_state}",
      #   "#{thread.death_arrest_executed}",
      #   "#{thread.scene_skip_pc}",
      #   "#{thread.mission_flag}",
      #   "#{thread.unknown1}",
      #   "#{thread.unknown2}",
      # ]]
      data3 = [
        ["#{thread.scm_return_stack[0]}"],
        ["#{thread.scm_return_stack[1]}"],
        ["#{thread.scm_return_stack[2]}"],
        ["#{thread.scm_return_stack[3]}"],
        ["#{thread.scm_return_stack[4]}"],
        ["#{thread.scm_return_stack[5]}"],
        ["#{thread.scm_return_stack[6]}"],
        ["#{thread.scm_return_stack[7]}"]
      ]

      data4 = []

      # opcode_prev = process.read(process.scm_offset + thread.scm_pc - 7,8).bytes
      # data4 << [opcode_prev.reverse[0..7].map{|g| g.to_s(16)}.join(" ")]
      # if opcode_prev.reverse[2..4].reverse == [0x01,0x00,0x04]
      #   data4 << ["int8 wait found"]
      # elsif opcode_prev.reverse[3..5].reverse == [0x01,0x00,0x05]
      #   data4 << ["int16 wait found"]
      # elsif opcode_prev.reverse[3..5].reverse == [0x01,0x00,0x02]
      #   data4 << ["var wait found"]
      # elsif opcode_prev.reverse[3..5].reverse == [0x01,0x00,0x03]
      #   data4 << ["lvar wait found"]
      # elsif opcode_prev.reverse[5..7].reverse == [0x01,0x00,0x01]
      #   data4 << ["int32 wait found"]
      # end
      # # data4 << [ opcode_prev.map{|b| b.to_s(16)}.join(" ") ]

      # opcode_at = process.read(process.scm_offset + thread.scm_pc,16)
      # data4 << [ opcode_at.bytes.map{|b| b.to_s(16)}.join(" ") ]

      self.elements[:table1].clear_highlight!
      self.elements[:table1].set_table(data1)
      # self.elements[:table2].clear_highlight!
      # self.elements[:table2].set_table(data2)
      self.elements[:table3].clear_highlight!
      self.elements[:table3].set_table(data3)
      self.elements[:table4].clear_highlight!
      self.elements[:table4].set_table(data4)
    end
  end
end


class GtaScm::ReplPanel < GtaScm::Panel
  BUFFER_LINES = 4
  def initialize(*)
    super
    self.elements[:header] = RuTui::Text.new(x: dx(0), y: dy(0), text: "")
    self.elements[:header].bg = 7
    self.elements[:header].fg = 0
    self.elements[:header].set_text("REPL".center(self.width))

    self.settings[:buffer_lines] = self.height - 1 - 3

    ty = 1
    self.settings[:buffer_lines].times do |i|
      self.elements[:"buffer_line_#{i}"] = RuTui::Text.new(x: dx(2), y: dy(ty), text: "")
      ty += 1
    end

    self.settings[:buffer_offset] = 0
    self.settings[:buffer] = []
    (self.settings[:buffer_lines]).times do |i|
      self.settings[:buffer] << ["input #{i}",[:input]]
      self.settings[:buffer] << ["output #{i}",[:output]]
    end

    ty = 1

    self.elements[:history_box] = RuTui::Box.new(
      x: dx(0),
      y: dy(ty),
      width: self.width,
      height: self.settings[:buffer_lines],
      corner: RuTui::Pixel.new(RuTui::Theme.get(:border).fg,RuTui::Theme.get(:background).bg,"+")
    )
    ty += self.settings[:buffer_lines]

    self.elements[:input_box] = RuTui::Box.new(
      x: dx(0),
      y: dy(ty - 1),
      width: self.width,
      height: 3,
      corner: RuTui::Pixel.new(RuTui::Theme.get(:border).fg,RuTui::Theme.get(:background).bg,"+")
    )
  end

  def update(process,is_attached,focused = false)
    
    buffer_offset = self.settings[:buffer_offset]
    buffer = self.settings[:buffer][-(buffer_offset+self.settings[:buffer_lines]-1)..-1]

    # self.elements[:header].set_text("buffer_offset: #{buffer_offset}")

    self.settings[:buffer_lines].times do |i|
      line = self.settings[:buffer][(0 - i - self.settings[:buffer_offset])]
      element = self.elements[:"buffer_line_#{self.settings[:buffer_lines] - i - 1}"]
      if line
        text = line[0]
        if line[1].include?(:input)
          element.fg = 6
        elsif line[1].include?(:output)
          element.fg = 5
        end
        element.set_text(text)
      else
        element.set_text( "-")
      end
    end

  end

  def mouse_scroll(x,y,dir,is_attached,process)
    self.settings[:buffer_offset] += dir
    self.settings[:buffer_offset] = 0 if self.settings[:buffer_offset] < 0

    max = self.settings[:buffer].size - self.settings[:buffer_lines] / 2
    self.settings[:buffer_offset] = max if self.settings[:buffer_offset] > max
  end

  def has_textfield
    true
  end
end

begin

$panels[:process] = GtaScm::ProcessPanel.new(63,0,62,1)
$panels[:thread_selector] = GtaScm::ThreadSelectorPanel.new(0,0,62,SIZE[0]-1)
$panels[:thread_info] = GtaScm::ThreadInfoPanel.new(10+4,1,42,50)
$panels[:thread_info].controller = $panels[:thread_selector]
$panels[:thread_list] = GtaScm::ThreadListPanel.new(0,1,10,74)
$panels[:thread_list].controller = $panels[:thread_selector]
$panels[:lvars] = GtaScm::LvarsPanel.new(10+4,SIZE[0]-35,48,32)
$panels[:lvars].controller = $panels[:thread_selector]
$panels[:gvars] = GtaScm::GvarsPanel.new(63,SIZE[0]-35,62,32)
$panels[:breakpoint] = GtaScm::BreakpointPanel.new(63,2,62,4)
$panels[:code_injector] = GtaScm::CodeInjectorPanel.new(63,3,62,10)
$panels[:repl] = GtaScm::ReplPanel.new(63,15,62,14)
# $panels[:mission_skipper] = GtaScm::MissionSkipperPanel.new(63,15,28,32)


screen = RuTui::Screen.new

$panels.each_pair do |_,panel|
  panel.add_elements_to_screen(screen)
end

RuTui::ScreenManager.add :default, screen
RuTui::ScreenManager.set_current :default

$panels.values.each(&:on_blur)
$focused_panel = :thread_selector


thr = ::Thread.new do
  loop do
    break if $exit

    start = Time.now

    begin
      begin
        process.detect_pid_and_attach!
      rescue
        #whatevs
      end

      is_attached = false
      if process.attached?
        is_attached = true
      else
        # not attached
      end

      $panels.each_pair do |name,panel|
        panel.update(process,is_attached,$focused_panel == name)
      end

      RuTui::ScreenManager.draw
      GC.start
    ensure
      sleep_time = (start + 0.25) - Time.now
      sleep(sleep_time) if sleep_time > 0.0
    end

  end
end

thr2 = ::Thread.new do
  print "\e[?1000h" # get mouse coords as keypress
  print "\e[?25l" # hide cursor
  loop do
    break if $exit

    print "\e[?25l" # hide cursor
    key = RuTui::Input.getc

    if key == :ctrl_c
      $exit = true
      break
    end

    key = key.force_encoding("ASCII-8BIT") if key.is_a?(String)

    $key = key

    if key.is_a?(String) && key.size > 1 && key.bytes[0] == 27
      x = key.bytes[4] - 32 - 1
      y = key.bytes[5] - 32 - 1
      # mouse event
      $panels.each_pair do |panel_name,panel|
        panel.abs_mouse_click(key.bytes[0],key.bytes[3],true,process)
        panel.abs_mouse_move(x,y,true,process)

        if x >= panel.x && x < panel.x + panel.width
          if y >= panel.y && y < panel.y + panel.height

            if key.bytes[3] == 32 # 32 = mouse down, 35 = mouse up

              if $focused_panel != panel_name
                $panels[$focused_panel].on_blur()
                $focused_panel = panel_name
                $panels[$focused_panel].on_focus()
              end

              panel.mouse_click(x-panel.x,y-panel.y,true,process)
            elsif key.bytes[3] == 67 # 67 = mouse move
              panel.mouse_move(x-panel.x,y-panel.y,true,process)
            elsif key.bytes[3] == 96 # scroll up
              panel.mouse_scroll(x-panel.x,y-panel.y,+1,true,process)
            elsif key.bytes[3] == 97 # scroll down
              panel.mouse_scroll(x-panel.x,y-panel.y,-1,true,process)
            end

          end
        end

      end
    else
      $panels.each_pair do |_,panel|
        panel.input(key,true,process)
      end
    end

  end
end

# thr3 = ::Thread.new do
#   loop do


#     sleep 0.1
#   end
# end


thr.join
thr2.join
# thr3.join

rescue => ex

  50.times { puts }
  puts ex.message
  puts ex.backtrace
  50.times { puts }

  raise ex
ensure
print "\e[?1000l" # get mouse coords as keypress
# print "\e[?1003l" # get mouse coords as keypress
print RuTui::Ansi.clear_color + RuTui::Ansi.clear
`reset`
end