#!/usr/bin/env ruby

# ./bin/sexp_change

if ENV["PWD"].split(/\//)[-1] == "gta-scm"
  $: << "./lib"
  require 'gta_scm'
end

require 'parser/current'

$scm = GtaScm::Scm.load_string("san-andreas","")
$scm.load_opcode_definitions!


# opt-in to most recent AST format:
# Parser::Builders::Default.emit_lambda = true
# Parser::Builders::Default.emit_procarg0 = true

ruby = <<-RUBY
  # x = 1000
  # y = 666.66

  # x += 50
  # y += 10.0

  # x -= 1
  # y -= 1.0

  # if x > 1000
  #   wait(50)
  # else
  #   terminate_this_script()
  # end

  loop do
    $player = create_player(0,1000.0,2000.0,20.0)
    $player_char = get_player_char($player)
    x,y,z = get_char_coordinates($_12)
    current_time = get_game_timer()
    if current_time > 5000
      add_one_off_sound(x,y,z,1056)
      terminate_this_script()
    else
      wait(50)
    end
  end
RUBY

parsed = Parser::CurrentRuby.parse(ruby)

def transform_node(node)
  case node.type

  when :block

    if node.children[0].type == :send && node.children[0].children[1] == :loop
      emit_loop(node,node.children[2])
    else
      raise "unknown block type: #{node.inspect}"
    end

  when :begin

    emit_block(node)

  # multiple assign
  # s(:masgn,
  #   s(:mlhs,
  #     s(:lvasgn, :x),
  #     s(:lvasgn, :y),
  #     s(:lvasgn, :z)),
  #   s(:send, nil, :get_char_coordinates,
  #     s(:gvar, :$_12)))
  # for opcodes, assigns seem to be the final args each time
  when :masgn

    [ emit_assignment_opcode_call(node.children[1],node.children[0],:masgn) ]

  # global var assign
  when :gvasgn

    [ emit_assignment_opcode_call(node.children[1],node.children[0],:gvasgn) ]

  # local var assign
  when :lvasgn

    [ emit_local_var_assign(node) ]

  when :op_asgn

    [ emit_operator_assign(node) ]

  when :if

    emit_if(node)

  when :send

    [ emit_opcode_call(node) ]

  else
    debugger
    raise "unknown node type #{node.type.inspect}"
  end
end

def emit_loop(loop_node,block_node)
  label = generate_label!
  [
    [:labeldef, label],
    *transform_node(block_node),
    [:goto,[[:label,label]]]
  ]
end

def emit_block(node)
  sexps = []
  node.children.each do |c|
    cc = transform_node(c)
    sexps += cc
  end
  sexps
end

def emit_local_var_assign(node)
  left = node.children[0]
  right = node.children[1]

  if right.type == :send
    return emit_assignment_opcode_call(right, node)
  end

  type = right.type
  if type == :int
    return [:set_lvar_int , lvar(node.children[0],:int) , [:int32,node.children[1].children[0]] ]
  end
  if type == :float
    return [:set_lvar_float , lvar(node.children[0],:float) , [:float32,node.children[1].children[0]] ]
  end
  if type == :lvar
    return emit_operator_assign(node)
  end

  raise "unknown lvar assignment #{node.inspect}"
end

ASSIGNMENT_OPERATORS = {
  :"=" => ["set","to"],
  :+ => ["add","to"],
  :- => ["sub","from"],
  :* => ["mult","by"],
  :/ => ["div","by"],
}
def emit_operator_assign(node)
  left,right,operator = nil,nil,nil

  if node.children.size == 3 && ASSIGNMENT_OPERATORS[ node.children[1] ]
    left = node.children[0]
    left_type = left.type
    left_value = nil

    right = node.children[2]
    right_type = right.type
    right_value = nil

    operator = node.children[1]
  elsif node.children.size == 2
    left = node
    left_type = :lvasgn
    right = node.children[1]
    right_type = right.type
    operator = :"="
  else
    raise "dunno???"
  end

  prefix,middle = *ASSIGNMENT_OPERATORS[ operator ]

  opcode_name = "#{prefix}_"

  if right_type == :int || right_type == :float
    opcode_name << "val"
    right_value = emit_value(node.children[2])
  elsif right_type == :lvar
    right_var_type = $lvar_names_to_types[ right.children[0] ]
    opcode_name << "#{right_var_type}_lvar"
    right_value = lvar(right.children[0],right_var_type)
  end

  opcode_name << "_#{middle}_"

  if left_type == :lvasgn
    if operator == :"="
      left_value = lvar(left.children[0],right_var_type)
    else
      left_value = lvar(left.children[0])
    end
    left_var_type = $lvar_names_to_types[ left.children[0] ]

    if operator == :"="
      left_var_type = $lvar_names_to_types[ right.children[0] ]
    end

    if left_var_type
      opcode_name << "#{left_var_type}_lvar"
    else
      debugger
      raise "no type for #{right.children[0]}"
    end

    if left_var_type && right_type != :lvar && left_var_type != right_type
      debugger
      raise "variable type mismatch (already declared as #{left_var_type}, assigning as #{right_type})"
    end
  else
    raise "can only handle lvasgn left hands"
  end

  return [ opcode_name.to_sym , [left_value,right_value] ]

end

def emit_opcode_call(node)
  opcode_name = node.children[1]
  opcode_def = $scm.opcodes[ opcode_name.to_s.upcase ]

  args = node.children[2..-1]
  args.map! {|a| emit_value(a)}

  [opcode_name,args]
end

def emit_assignment_opcode_call(opcode_call_node,variable_node,assign_type = nil)
  opcode_name = opcode_call_node.children[1]
  opcode_def = $scm.opcodes[ opcode_name.to_s.upcase ]

  # multi assign
  if variable_node.is_a?(Parser::AST::Node) && variable_node.type == :mlhs
    args = opcode_call_node.children[2..-1]
    args.map! {|a| emit_value(a)}

    variable_node.children.each_with_index do |arg,i|
      arg_def = opcode_def.arguments[i]
      if arg.type == :lvasgn
        args << lvar( arg.children[0] , arg_def[:type] )
      else
        raise "can only handle lvar assigns"
      end
    end
  else
    args = opcode_call_node.children[2..-1]
    args.map! {|a| emit_value(a)}
    if assign_type == :gvasgn
      args << gvar(variable_node.to_s.gsub('$',''))
    else
      args = []
      return_args = opcode_def.arguments.select {|a| a[:return_value]}
      return_args.each do |return_arg|
        if variable_node.type == :lvasgn
          args[ return_arg[:_i] ] = lvar( variable_node.children[0] , return_arg[:type] )
        else
          raise "can only handle lvar assigns"
        end
      end
    end
  end

  if args.size != opcode_def.arguments.size
    raise "wrong final arg count for #{opcode_name} (expected #{opcode_def.arguments.size}, got #{args.size})"
  end

  if args.size == 0
    return [ opcode_name ]
  else
    return [ opcode_name, args ]
  end
end

COMPARISON_OPERATORS = {
  :>  => [nil,"greater_than"],
  :<  => ["not_","greater_than_or_equal_to"]
}
def emit_conditional_opcode_call(node)
  if node.children.size == 3 && COMPARISON_OPERATORS[ node.children[1] ]
    left_type = node.children[0].type
    left_value = nil
    right_type = node.children[2].type
    right_value = nil

    not_operator,sign_operator = *COMPARISON_OPERATORS[ node.children[1] ]

    opcode_name = "#{not_operator}is_"

    if left_type == :lvar
      left_value = lvar(node.children[0].children[0])
      left_var_type = $lvar_names_to_types[ node.children[0].children[0] ]
      raise "can't find type for #{node.children[0].children[0]}" if !left_var_type
      opcode_name << "#{left_var_type}_lvar"
    else
      raise "can only handle lvars on left side"
    end

    opcode_name << "_#{sign_operator}_"

    if right_type == :int || right_type == :float
      opcode_name << "number"
      right_value = emit_value(node.children[2])
    end
  end

  [opcode_name.to_sym,[left_value,right_value]]
end

def emit_if(node)

  andor_id, conditions = *emit_if_conditions( node.children[0] )

  if node.children.size == 2 # if/end
    false_label = generate_label!
    [
      [:andor,[[andor_id]]],
      *conditions,
      [:goto_if_false,[[:label, false_label]]],
      *transform_node(node.children[1]),
      [:labeldef, false_label]
    ]
  elsif node.children.size == 3 # if/else/end
    true_label = generate_label!
    false_label = generate_label!
    end_label = generate_label!
    [
      [:andor,[[andor_id]]],
      *conditions,
      [:goto_if_false,[[:label, false_label]]],
      *transform_node(node.children[1]),
      [:goto,[[:label,end_label]]],
      [:labeldef, false_label],
      *transform_node(node.children[2]),
      [:labeldef, end_label]
    ]

  end
end

def emit_value(node)
  if node.type == :int || node.type == :float
    type = {int: :int32, float: :float32}[node.type]
    [type,node.children[0]]
  elsif node.type == :lvar
    lvar(node.children[0])
  elsif node.type == :gvar
    name = node.children[0].to_s.gsub(%r(^\$),'')
    if matches = name.match(%r(^_(\d+)))
      [:dmavar, matches[1].to_i]
    else
      gvar(name)
    end
  else
    raise "emit_value ??? #{node.inspect}"
  end
end

def emit_if_conditions(node)
  case node.type
  when :and
    raise ArgumentError
  when :or
    raise ArgumentError
  when :send
    [ 0, [emit_conditional_opcode_call(node)] ]
  end
end

$generate_label_counter = 0
def generate_label!
  $generate_label_counter += 1
  :"label_#{$generate_label_counter}"
end

$lvar_names_to_types = {}
$lvar_names_to_ids = {}
$generate_lvar_counter = -1
def lvar(name,type = nil)
  id = if $lvar_names_to_ids[name]
    if type && $lvar_names_to_types[name] && type != $lvar_names_to_types[name]
      raise "mismatched type for #{name}"
    end
    $lvar_names_to_ids[name]
  else
    $generate_lvar_counter += 1
    $lvar_names_to_ids[name] = $generate_lvar_counter
    if type
      $lvar_names_to_types[name] = type
    end
    $lvar_names_to_ids[name]
  end
  [:lvar, id, name]
end

$gvar_names_to_ids = {}
$generate_gvar_counter = 4
def gvar(name,type = nil)
  name = name.to_sym
  id = if $gvar_names_to_ids[name]
    $gvar_names_to_ids[name]
  else
    $generate_gvar_counter += 4
    $gvar_names_to_ids[name] = $generate_gvar_counter

    $gvar_names_to_ids[name]
  end
  [:var, name]
end

scm = transform_node(parsed)
# print JSON.pretty_generate(scm)
scm.each do |node|
  puts Elparser::encode(node)
end






